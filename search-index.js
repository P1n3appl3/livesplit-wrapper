var searchIndex = JSON.parse('{\
"bytemuck":{"doc":"This crate gives small utilities for casting between plain …","t":[13,8,2,8,16,18,18,8,13,8,4,8,13,13,8,8,8,11,11,5,5,5,5,5,5,5,0,11,11,11,11,11,5,5,11,11,11,11,11,11,14,14,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,5,5,11,5,5,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,16,8,4,13,13,11,11,5,5,5,5,5,11,11,11,11,11,11,5,5,11,11,10,5,5,5,5,5,5,11,5,5,11,5,11,12],"n":["AlignmentMismatch","AnyBitPattern","CheckedBitPattern","Contiguous","Int","MAX_VALUE","MIN_VALUE","NoUninit","OutputSliceWouldHaveSlop","Pod","PodCastError","PodInOption","SizeMismatch","TargetAlignmentGreaterAndInputNotAligned","TransparentWrapper","Zeroable","ZeroableInOption","borrow","borrow_mut","bytes_of","bytes_of_mut","cast","cast_mut","cast_ref","cast_slice","cast_slice_mut","checked","clone","eq","fmt","fmt","from","from_bytes","from_bytes_mut","from_integer","from_integer","hash","into","into_integer","into_integer","offset_of","offset_of","peel","peel","peel_mut","peel_mut","peel_ref","peel_ref","peel_slice","peel_slice","peel_slice_mut","peel_slice_mut","pod_align_to","pod_align_to_mut","pod_read_unaligned","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from","try_from_bytes","try_from_bytes_mut","try_into","try_pod_read_unaligned","type_id","wrap","wrap","wrap_mut","wrap_mut","wrap_ref","wrap_ref","wrap_slice","wrap_slice","wrap_slice_mut","wrap_slice_mut","zeroed","zeroed","Bits","CheckedBitPattern","CheckedCastError","InvalidBitPattern","PodCastError","borrow","borrow_mut","cast","cast_mut","cast_ref","cast_slice","cast_slice_mut","clone","eq","fmt","fmt","from","from","from_bytes","from_bytes_mut","hash","into","is_valid_bit_pattern","pod_read_unaligned","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from","try_from_bytes","try_from_bytes_mut","try_into","try_pod_read_unaligned","type_id","0"],"q":["bytemuck","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","bytemuck::checked","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","bytemuck::checked::CheckedCastError"],"d":["For this type of cast the alignments must be exactly the …","Marker trait for “plain old data” types that are valid …","","A trait indicating that:","The primitive integer type with an identical …","The upper <em>inclusive</em> bound for valid instances of this type.","The lower <em>inclusive</em> bound for valid instances of this type.","Marker trait for “plain old data” types with no uninit …","If the element size changes then the output slice changes …","Marker trait for “plain old data”.","The things that can go wrong when casting between <code>Pod</code> data …","Trait for types which are Pod when wrapped in Option.","When casting a slice you can’t convert between ZST …","You tried to cast a slice to an element type with a higher …","A trait which indicates that a type is a …","Trait for types that can be safely created with <code>zeroed</code>.","Trait for types which are Zeroable when wrapped in Option.","","","Re-interprets <code>&amp;T</code> as <code>&amp;[u8]</code>.","Re-interprets <code>&amp;mut T</code> as <code>&amp;mut [u8]</code>.","Cast <code>T</code> into <code>U</code>","Cast <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Cast <code>&amp;T</code> into <code>&amp;U</code>.","Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.","Cast <code>&amp;mut [T]</code> into <code>&amp;mut [U]</code>.","Checked versions of the casting functions exposed in crate …","","","","","Returns the argument unchanged.","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","If <code>value</code> is within the range for valid instances of this …","If <code>value</code> is within the range for valid instances of this …","","Calls <code>U::from(self)</code>.","Perform the conversion from <code>C</code> into the underlying integral …","Perform the conversion from <code>C</code> into the underlying integral …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Convert the wrapper type into the inner type.","Convert the wrapper type into the inner type.","Convert a mutable reference to the wrapper type into a …","Convert a mutable reference to the wrapper type into a …","Convert a reference to the wrapper type into a reference …","Convert a reference to the wrapper type into a reference …","Convert a slice to the wrapped type into a slice to the …","Convert a slice to the wrapped type into a slice to the …","Convert a mutable slice to the wrapped type into a mutable …","Convert a mutable slice to the wrapped type into a mutable …","As <code>align_to</code>, but safe because of the <code>Pod</code> bound.","As <code>align_to_mut</code>, but safe because of the <code>Pod</code> bound.","Reads the slice into a <code>T</code> value.","Try to cast <code>T</code> into <code>U</code>.","Try to convert a <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Try to convert a <code>&amp;T</code> into <code>&amp;U</code>.","Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in …","Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a …","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Reads from the bytes as if they were a <code>T</code>.","","Convert the inner type into the wrapper type.","Convert the inner type into the wrapper type.","Convert a mutable reference to the inner type into a …","Convert a mutable reference to the inner type into a …","Convert a reference to the inner type into a reference to …","Convert a reference to the inner type into a reference to …","Convert a slice to the inner type into a slice to the …","Convert a slice to the inner type into a slice to the …","Convert a mutable slice to the inner type into a mutable …","Convert a mutable slice to the inner type into a mutable …","Calls <code>zeroed</code>.","Calls <code>zeroed</code>.","<code>Self</code> <em>must</em> have the same layout as the specified <code>Bits</code> …","A marker trait that allows types that have some invalid …","The things that can go wrong when casting between …","When casting to a <code>CheckedBitPattern</code> type, it is possible …","An error occurred during a true-[<code>Pod</code>] cast","","","Cast <code>T</code> into <code>U</code>","Cast <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Cast <code>&amp;T</code> into <code>&amp;U</code>.","Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.","Cast <code>&amp;mut [T]</code> into <code>&amp;mut [U]</code>.","","","","","","Returns the argument unchanged.","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Calls <code>U::from(self)</code>.","If this function returns true, then it must be valid to …","Reads the slice into a <code>T</code> value.","Try to cast <code>T</code> into <code>U</code>.","Try to convert a <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Try to convert a <code>&amp;T</code> into <code>&amp;U</code>.","Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in …","Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a …","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Reads from the bytes as if they were a <code>T</code>.","",""],"i":[3,0,0,0,12,12,12,0,3,0,0,0,3,3,0,0,0,3,3,0,0,0,0,0,0,0,0,3,3,3,3,3,0,0,12,12,3,3,12,12,0,0,13,13,13,13,13,13,13,13,13,13,0,0,0,0,0,0,0,0,3,0,0,3,0,3,13,13,13,13,13,13,13,13,13,13,14,14,10,0,0,11,11,11,11,0,0,0,0,0,11,11,11,11,11,11,0,0,11,11,10,0,0,0,0,0,0,11,0,0,11,0,11,15],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[1,2],[[]],[[]],[[]],[[]],0,[3,3],[[3,3],4],[[3,5],6],[[3,5],6],[[]],[[]],[[]],[[],7],[[],7],[3],[[]],[[]],[[]],0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],2],[1,[[8,[2,3]]]],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],8],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],8],[[],[[8,[2,3]]]],[[],9],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],0,0,0,0,0,[[]],[[]],[1,10],[[]],[[]],[[]],[[]],[11,11],[[11,11],4],[[11,5],6],[[11,5],6],[3,11],[[]],[[]],[[]],[11],[[]],[[],4],[[],2],[1,[[8,[10,11]]]],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],8],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],8],[[],[[8,[10,11]]]],[[],9],0],"p":[[8,"NoUninit"],[8,"AnyBitPattern"],[4,"PodCastError"],[15,"bool"],[3,"Formatter"],[6,"Result"],[4,"Option"],[4,"Result"],[3,"TypeId"],[8,"CheckedBitPattern"],[4,"CheckedCastError"],[8,"Contiguous"],[8,"TransparentWrapper"],[8,"Zeroable"],[13,"PodCastError"]]},\
"livesplit_wrapper":{"doc":"LiveSplit One uses dynamically loaded WASM modules for …","t":[6,13,4,13,8,13,13,8,3,6,13,8,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,14,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10],"n":["Address","Ended","Error","FailedRead","HostFunctions","NotRunning","Paused","Pod","Process","Result","Running","Splitter","TimerState","attach","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","drop","eq","fmt","fmt","fmt","from","from","from","into","into","into","module","new","pause","print","read","read_cstr","read_into_buf","register_autosplitter","reset","set_game_time","set_tick_rate","set_variable","split","start","state","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","unpause","update"],"q":["livesplit_wrapper","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["An address in the attached processes memory.","The timer is stopped because a run was completed.","Currently the only possible error is a failed memory read …","A memory read on the attached process failed","The autosplitter’s interface for interacting with the …","The timer has yet to be started.","The timer is paused.","Marker trait for “plain old data”.","A handle representing an attached process that can be used …","The result of an attempt to read process memory.","The timer is currently running.","The main autosplitter trait.","The possible states of the timer.","Attach to a process running on the same machine as the …","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Search for a module (aka dynamic library) loaded by the …","Called when the LiveSplit runtime instantiates your …","Pause the game time counter. This is often used when …","Output a message. This can be used for debugging and/or …","Reads a single value from the attached processes memory …","Reads a null terminated string starting at the given base …","Read bytes from the attached processes memory space …","Wires up the necessary c interface for a type that …","Reset the run. Don’t do this automatically when a run …","Set the game time. Note that if the timer is not paused, …","Set the rate at which the <code>update</code> function will be called …","Set a variable which can be displayed by LiveSplit. This …","Mark the current split as finished and move to the next …","Start the timer for a run. Note that this will silently do …","Get the current state of the timer. This is how the …","","","","","","","","","","","Resume the game time counter. Note that","Called periodically by the LiveSplit runtime. To change …"],"i":[0,4,0,6,0,4,4,0,0,0,4,0,0,17,6,2,4,6,2,4,4,4,2,4,6,2,4,6,2,4,6,2,4,2,18,17,17,2,2,2,0,17,17,17,17,17,17,17,4,6,2,4,6,2,4,6,2,4,17,18],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,[1,[[3,[2]]]],[[]],[[]],[[]],[[]],[[]],[[]],[4,4],[[]],[2],[[4,4],5],[[6,7],8],[[2,7],8],[[4,7],8],[[]],[[]],[[]],[[]],[[]],[[]],[[2,1],[[3,[9]]]],[[]],[[]],[1],[[2,9],[[11,[10]]]],[[2,12],[[11,[13]]]],[[2,9],11],0,[[]],[14],[14],[[1,1]],[[]],[[]],[[],4],[[]],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],16],[[],16],[[],16],[[]],[[]]],"p":[[15,"str"],[3,"Process"],[4,"Option"],[4,"TimerState"],[15,"bool"],[4,"Error"],[3,"Formatter"],[6,"Result"],[6,"Address"],[8,"Pod"],[6,"Result"],[15,"u64"],[3,"String"],[15,"f64"],[4,"Result"],[3,"TypeId"],[8,"HostFunctions"],[8,"Splitter"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
