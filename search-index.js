var searchIndex = JSON.parse('{\
"bytemuck":{"doc":"This crate gives small utilities for casting between plain …","t":[13,8,16,18,18,18,18,13,8,4,13,13,8,8,11,11,5,5,5,5,5,5,5,11,11,11,11,11,5,5,11,11,11,11,11,11,14,14,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,5,11,5,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["AlignmentMismatch","Contiguous","Int","MAX_VALUE","MAX_VALUE","MIN_VALUE","MIN_VALUE","OutputSliceWouldHaveSlop","Pod","PodCastError","SizeMismatch","TargetAlignmentGreaterAndInputNotAligned","TransparentWrapper","Zeroable","borrow","borrow_mut","bytes_of","bytes_of_mut","cast","cast_mut","cast_ref","cast_slice","cast_slice_mut","clone","eq","fmt","fmt","from","from_bytes","from_bytes_mut","from_integer","from_integer","hash","into","into_integer","into_integer","offset_of","offset_of","peel","peel","peel_mut","peel_mut","peel_ref","peel_ref","peel_slice","peel_slice","peel_slice_mut","peel_slice_mut","pod_align_to","pod_align_to_mut","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from","try_from_bytes","try_from_bytes_mut","try_into","type_id","wrap","wrap","wrap_mut","wrap_mut","wrap_ref","wrap_ref","wrap_slice","wrap_slice","wrap_slice_mut","wrap_slice_mut","zeroed","zeroed"],"q":["bytemuck","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["For this type of cast the alignments must be exactly the …","A trait indicating that:","The primitive integer type with an identical …","The upper <em>inclusive</em> bound for valid instances of this type.","The upper <em>inclusive</em> bound for valid instances of this type.","The lower <em>inclusive</em> bound for valid instances of this type.","The lower <em>inclusive</em> bound for valid instances of this type.","If the element size changes then the output slice changes …","Marker trait for “plain old data”.","The things that can go wrong when casting between <code>Pod</code> data …","When casting a slice you can’t convert between ZST …","You tried to cast a slice to an element type with a higher …","A trait which indicates that a type is a …","Trait for types that can be safely created with <code>zeroed</code>.","","","Re-interprets <code>&amp;T</code> as <code>&amp;[u8]</code>.","Re-interprets <code>&amp;mut T</code> as <code>&amp;mut [u8]</code>.","Cast <code>T</code> into <code>U</code>","Cast <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Cast <code>&amp;T</code> into <code>&amp;U</code>.","Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.","Cast <code>&amp;mut [T]</code> into <code>&amp;mut [U]</code>.","","","","","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","If <code>value</code> is within the range for valid instances of this …","If <code>value</code> is within the range for valid instances of this …","","","Perform the conversion from <code>C</code> into the underlying integral …","Perform the conversion from <code>C</code> into the underlying integral …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Convert the wrapper type into the inner type.","Convert the wrapper type into the inner type.","Convert a mutable reference to the wrapper type into a …","Convert a mutable reference to the wrapper type into a …","Convert a reference to the wrapper type into a reference …","Convert a reference to the wrapper type into a reference …","Convert a slice to the wrapped type into a slice to the …","Convert a slice to the wrapped type into a slice to the …","Convert a mutable slice to the wrapped type into a mutable …","Convert a mutable slice to the wrapped type into a mutable …","As <code>align_to</code>, but safe because of the <code>Pod</code> bound.","As <code>align_to_mut</code>, but safe because of the <code>Pod</code> bound.","Try to cast <code>T</code> into <code>U</code>.","Try to convert a <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Try to convert a <code>&amp;T</code> into <code>&amp;U</code>.","Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in …","Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a …","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","","Convert the inner type into the wrapper type.","Convert the inner type into the wrapper type.","Convert a mutable reference to the inner type into a …","Convert a mutable reference to the inner type into a …","Convert a reference to the inner type into a reference to …","Convert a reference to the inner type into a reference to …","Convert a slice to the inner type into a slice to the …","Convert a slice to the inner type into a slice to the …","Convert a mutable slice to the inner type into a mutable …","Convert a mutable slice to the inner type into a mutable …","Calls <code>zeroed</code>.","Calls <code>zeroed</code>."],"i":[1,0,2,2,2,2,2,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,2,2,1,1,2,2,0,0,3,3,3,3,3,3,3,3,3,3,0,0,0,0,0,0,0,1,0,0,1,1,3,3,3,3,3,3,3,3,3,3,4,4],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[]],[[]],[[]],[[]],[[["pod",8]],["pod",8]],[[]],[[]],[[]],[[]],[[],["podcasterror",4]],[[["podcasterror",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["option",4]],[[],["option",4]],[[]],[[]],[[]],[[]],null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["pod",8]],["result",4,[["pod",8],["podcasterror",4]]]],[[],["result",4,[["podcasterror",4]]]],[[],["result",4,[["podcasterror",4]]]],[[],["result",4,[["podcasterror",4]]]],[[],["result",4,[["podcasterror",4]]]],[[],["result",4]],[[],["result",4,[["podcasterror",4]]]],[[],["result",4,[["podcasterror",4]]]],[[],["result",4]],[[],["typeid",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]]],"p":[[4,"PodCastError"],[8,"Contiguous"],[8,"TransparentWrapper"],[8,"Zeroable"]]},\
"livesplit_wrapper":{"doc":"A safe wrapper of the livesplit-core api for creating …","t":[6,4,13,13,8,13,13,3,13,8,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,14,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10],"n":["Address","Error","FailedRead","Finished","HostFunctions","NotRunning","Paused","Process","Running","Splitter","TimerState","attach","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","drop","eq","fmt","fmt","fmt","from","from","from","into","into","into","module","new","pause","print","read","read_into_buf","register_autosplitter","reset","set_game_time","set_tick_rate","set_variable","split","start","state","to_owned","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","unpause","update"],"q":["livesplit_wrapper","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["An address in the attached processes memory.","Currently the only possible error is a failed memory read …","A memory read on the attached process failed","The timer is stopped because a run was completed.","The autosplitter’s interface for interacting with the …","The timer has yet to be started.","The timer is paused.","A handle representing an attached process that can be used …","The timer is currently running.","The main autosplitter trait.","The possible states of the timer.","Attach to a process running on the same machine as the …","","","","","","","","","","","","","","","","","","","","Search for a module (aka dynamic library) loaded by the …","Called when the LiveSplit runtime instantiates your …","Pause the game time counter. This is often used when …","Output a message. This can be used for debugging and/or …","Reads a single value from the attached processes memory …","Read bytes from the attached processes memory space …","Wires up the necessary c interface for a type that …","Reset the run. Don’t do this automatically when a run …","Set the game time. Note that if the timer is not paused, …","Set the rate at which the <code>update</code> function will be called …","Set a variable which can be displayed by LiveSplit. This …","Mark the current split as finished and move to the next …","Start the timer for a run. Note that this will silently do …","Get the current state of the timer. This is how the …","","","","","","","","","","","Resume the game time counter. Note that","Called periodically by the LiveSplit runtime. To change …"],"i":[0,0,1,2,0,2,2,0,2,0,0,3,1,4,2,1,4,2,2,2,4,2,1,4,2,1,4,2,1,4,2,4,5,3,3,4,4,0,3,3,3,3,3,3,3,2,1,4,2,1,4,2,1,4,2,3,5],"f":[null,null,null,null,null,null,null,null,null,null,null,[[["str",15]],["option",4,[["process",3]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["timerstate",4]],[[]],[[]],[[["timerstate",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[["str",15]],["option",4,[["address",6]]]],[[]],[[]],[[["str",15]]],[[["address",6]],["result",4,[["pod",8],["error",4]]]],[[["address",6]],["result",4,[["error",4]]]],null,[[]],[[["f64",15]]],[[["f64",15]]],[[["str",15],["str",15]]],[[]],[[]],[[],["timerstate",4]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[]],[[]]],"p":[[4,"Error"],[4,"TimerState"],[8,"HostFunctions"],[3,"Process"],[8,"Splitter"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};